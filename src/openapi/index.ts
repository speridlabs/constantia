import fs from 'fs';
import path from 'path';

import {
    OpenAPISpec,
    PathsObject,
    OperationObject,
    ComponentsObject,
    SecuritySchemeObject,
    SecurityRequirementObject,
} from './types';
import {
    createOpenAPIResponses,
    createOpenAPIParameters,
    createOpenAPIRequestBody,
} from './helpers';

import { logger } from '../logger';

import { Get, Controller } from '../decorators';
import { type IFrameworkAdapter } from '../adapters';
import { MetadataStorage, type ControllerMetadata } from '../metadata';

export interface OpenAPIConfig {
    title?: string;
    version?: string;
    description?: string;
    securitySchemes?: {
        [schemeName: string]: SecuritySchemeObject;
    };
}

@Controller('/openapi.json', false)
class OpenAPIController {
    private cachedSpec: OpenAPISpec | null = null;
    private config: OpenAPIConfig;

    constructor(config: OpenAPIConfig = {}) {
        this.config = config;
    }

    private generateOpenAPISpec(
        allMetadata: ControllerMetadata[],
    ): OpenAPISpec {
        if (this.cachedSpec) return this.cachedSpec;

        const paths: PathsObject = {};
        const allTags: string[] = [];
        const components: ComponentsObject = { schemas: {}, responses: {} };

        for (const controllerMeta of allMetadata) {
            const controllerTag =
                controllerMeta.path.split('/').filter(Boolean).pop() ||
                'Default';
            allTags.push(controllerTag);

            for (const routeMeta of controllerMeta.routes) {
                const fullPath = (controllerMeta.path + routeMeta.path)
                    .replace(/\/+/g, '/')
                    .replace(/:([a-zA-Z0-9_]+)/g, '{$1}');

                if (!paths[fullPath]) paths[fullPath] = {};

                type HttpMethodKey =
                    | 'get'
                    | 'put'
                    | 'post'
                    | 'delete'
                    | 'patch';
                const httpMethod =
                    routeMeta.method.toLowerCase() as HttpMethodKey;

                if (
                    !['get', 'put', 'post', 'delete', 'patch'].includes(
                        httpMethod,
                    )
                )
                    throw new Error('Invalid HTTP method: ' + httpMethod);

                if (paths[fullPath][httpMethod])
                    logger.warn(
                        `OpenAPI: Duplicate operation detected for ${httpMethod.toUpperCase()} ${fullPath}. Overwriting.`,
                    );

                const operation: OperationObject = {
                    tags: [controllerTag],
                    operationId: `${routeMeta.methodName}`,
                    parameters: createOpenAPIParameters(
                        routeMeta.parameters,
                        components,
                    ),
                    requestBody: createOpenAPIRequestBody(
                        routeMeta.parameters,
                        components,
                    ),
                    responses: createOpenAPIResponses(routeMeta, components),
                    summary: `${controllerTag}_${routeMeta.methodName}`,
                };

                if (routeMeta.security.length > 0) {
                    const securityReq: SecurityRequirementObject = {};
                    for (const scheme of routeMeta.security) {
                        securityReq[scheme] = [];
                    }
                    operation.security = [securityReq];
                }

                if (operation.parameters?.length === 0)
                    delete operation.parameters;

                paths[fullPath][httpMethod] = operation;
            }
        }

        if (this.config.securitySchemes) {
            components.securitySchemes = { ...this.config.securitySchemes };
        }

        this.cachedSpec = {
            openapi: '3.0.3',
            info: {
                title: this.config.title || 'API',
                version: this.config.version || '1.0.0',
                description:
                    this.config.description ||
                    'API documentation generated by Constantia',
            },
            tags: allTags.map((tag) => ({
                name: tag,
                description: `Operations related to ${tag}`,
            })),
            paths: paths,
            components: components,
        };

        return this.cachedSpec;
    }

    @Get()
    async getOpenAPISpec(): Promise<OpenAPISpec> {
        const allMetadata = Array.from(
            MetadataStorage.getInstance().controllers.values(),
        ).filter((meta) => meta.path !== '/openapi.json');

        return this.generateOpenAPISpec(allMetadata);
    }
}

export interface RegisterOpenAPIOptions {
    config?: OpenAPIConfig;
}

export const registerOpenAPI = async (
    adapter: IFrameworkAdapter,
    options: RegisterOpenAPIOptions = {},
): Promise<void> => {
    const metadata = MetadataStorage.getInstance();

    metadata.addController(OpenAPIController, '/openapi.json');

    const args = process.argv.slice(2);
    let onlyGenerate = false;
    let specFileArgIndex = args.indexOf('--generate-spec');

    if (specFileArgIndex === -1) {
        specFileArgIndex = args.indexOf('--only-generate-spec');
        onlyGenerate = specFileArgIndex !== -1;
    }
    if (specFileArgIndex !== -1) {
        let specFilePath = args[specFileArgIndex + 1];
        if (!specFilePath || specFilePath.startsWith('--'))
            specFilePath = './openapi.json';

        const fullPath = path.resolve(specFilePath);
        const dirPath = path.dirname(fullPath);

        const controller = new OpenAPIController(options.config);
        const spec = await controller.getOpenAPISpec();

        await fs.promises.mkdir(dirPath, { recursive: true });
        await fs.promises.writeFile(fullPath, JSON.stringify(spec, null, 2));

        const pathParts = fullPath.split('/').filter(Boolean);
        const lastThreeDirs = pathParts.slice(-3).join('/');
        logger.info(`OpenAPI spec written to ...${lastThreeDirs}`);

        if (onlyGenerate) process.exit(0);
    }

    const openAPIControllerMetadata =
        metadata.controllers.get(OpenAPIController);

    if (!openAPIControllerMetadata)
        throw new Error('Failed to register OpenAPI controller');

    adapter.registerControllers([
        [openAPIControllerMetadata],
        [OpenAPIController],
    ]);
};

export { type OpenAPISpec };
